#!/bin/sh
# shellcheck shell=sh

set -eu

. /usr/local/bin/backend-functions

SCRIPT_NAME="ENTRYPOINT"

# Display project information
echo "===================================================================================="
echo "ðŸš€ NordVPN WireGuard Docker Container"
echo "===================================================================================="
echo "ðŸ“‹ Description: Docker container for NordVPN with WireGuard and advanced networking"
echo "ðŸ‘¤ Author: Alexander Zinchenko <alexander@zinchenko.com>"
echo "ðŸ”— Repository: https://github.com/azinchen/nordvpn-wg"
echo "ðŸ“š Documentation: https://github.com/azinchen/nordvpn-wg#readme"
echo "ðŸ·ï¸ Image Version: __IMAGE_VERSION__"
echo "ðŸ“… Build Date: __BUILD_DATE__"
echo "===================================================================================="

log "$SCRIPT_NAME" "Applying security rules"

# ---- helpers ---------------------------------------------------------------

kernel_ge_4_18()
{
    ver="$(uname -r | awk -F- '{print $1}')"    # e.g., 4.4.0 or 6.8.0
    major="$(echo "$ver" | awk -F. '{print $1}')"
    minor="$(echo "$ver" | awk -F. '{print $2}')"
    [ -n "$minor" ] || minor=0
    if [ "$major" -gt 4 ]; then return 0; fi
    if [ "$major" -lt 4 ]; then return 1; fi
    [ "$minor" -ge 18 ]
}

try_policy()
{
    _bin="$1"
    # Prove backend can change policy on this kernel (DROP then revert)
    $_bin -t filter -S >/dev/null 2>&1 || return 1
    if $_bin -t filter -P OUTPUT DROP >/dev/null 2>&1; then
        $_bin -t filter -P OUTPUT ACCEPT >/dev/null 2>&1 || true
        return 0
    fi
    return 1
}

flush_nft_if_dirty_v4()
{
    # Flush nftables v4 only if we selected legacy for v4 AND nft tables actually carry rules
    if [ "${_IPT}" = "iptables-legacy" ] && command -v iptables-nft >/dev/null 2>&1; then
        if iptables-nft -S 2>/dev/null | grep -q '^-A ' || iptables-nft -t nat -S 2>/dev/null | grep -q '^-A '; then
            iptables-nft -F 2>/dev/null || true
            iptables-nft -t nat -F 2>/dev/null || true
            iptables-nft -X 2>/dev/null || true
            log "$SCRIPT_NAME" "Flushed IPv4 nftables to avoid mixed stacks"
        fi
    fi
}

flush_nft_if_dirty_v6()
{
    # Flush nftables v6 only if we selected legacy for v6 AND nft v6 tables actually carry rules
    if [ -n "${_IP6T:-}" ] && [ "${_IP6T}" = "ip6tables-legacy" ] && command -v ip6tables-nft >/dev/null 2>&1; then
        if ip6tables-nft -S 2>/dev/null | grep -q '^-A ' || ip6tables-nft -t nat -S 2>/dev/null | grep -q '^-A '; then
            ip6tables-nft -F 2>/dev/null || true
            ip6tables-nft -t nat -F 2>/dev/null || true
            ip6tables-nft -X 2>/dev/null || true
            log "$SCRIPT_NAME" "Flushed IPv6 nftables to avoid mixed stacks"
        fi
    fi
}

# ---- IPv4 backend picker: prefer nft on â‰¥4.18; else legacy -----------------

pick_ipv4_backend()
{
    _IPT=""
    if kernel_ge_4_18; then
        if command -v iptables >/dev/null 2>&1 && iptables -V 2>&1 | grep -qi "(nf_tables)"; then
            try_policy iptables && _IPT="iptables"
        fi
        [ -n "$_IPT" ] || { command -v iptables-legacy >/dev/null 2>&1 && try_policy iptables-legacy && _IPT="iptables-legacy"; }
        [ -n "$_IPT" ] || { command -v iptables >/dev/null 2>&1 && try_policy iptables && _IPT="iptables"; }
    else
        if command -v iptables-legacy >/dev/null 2>&1; then
            try_policy iptables-legacy && _IPT="iptables-legacy"
        fi
        [ -n "$_IPT" ] || { command -v iptables >/dev/null 2>&1 && try_policy iptables && _IPT="iptables"; }
    fi
    [ -n "$_IPT" ] || { log_error "$SCRIPT_NAME" "ERROR: no working iptables (IPv4) found"; exit 1; }

    log "$SCRIPT_NAME" "Kernel: $(uname -r)"
    log "$SCRIPT_NAME" "Using iptables backend: ${_IPT}"
}

# ---- IPv6 backend picker: prefer nft on â‰¥4.18; else legacy -----------------

pick_ipv6_backend()
{
    _IP6T=""
    if kernel_ge_4_18; then
        if command -v ip6tables >/dev/null 2>&1 && ip6tables -V 2>&1 | grep -qi "(nf_tables)"; then
            try_policy ip6tables && _IP6T="ip6tables"
        fi
        [ -n "$_IP6T" ] || { command -v ip6tables-legacy >/dev/null 2>&1 && try_policy ip6tables-legacy && _IP6T="ip6tables-legacy"; } || true
        [ -n "$_IP6T" ] || { command -v ip6tables >/dev/null 2>&1 && try_policy ip6tables && _IP6T="ip6tables"; } || true
    else
        if command -v ip6tables-legacy >/dev/null 2>&1; then
            try_policy ip6tables-legacy && _IP6T="ip6tables-legacy"
        fi
        [ -n "$_IP6T" ] || { command -v ip6tables >/dev/null 2>&1 && try_policy ip6tables && _IP6T="ip6tables"; } || true
    fi

    # Last-resort: if a binary exists at all, use it (even if probe failed)
    [ -n "$_IP6T" ] || { command -v ip6tables-legacy >/dev/null 2>&1 && _IP6T="ip6tables-legacy"; } || true
    [ -n "$_IP6T" ] || { command -v ip6tables >/dev/null 2>&1 && _IP6T="ip6tables"; } || true

    if [ -n "$_IP6T" ]; then
        log "$SCRIPT_NAME" "Using ip6tables backend: ${_IP6T}"
    else
        log "$SCRIPT_NAME" "IPv6 support unavailable"
    fi
}

verify_ipv6_backend()
{
    # If we picked something for v6, make sure v6 tables actually exist and nat table is usable.
    if [ -n "$_IP6T" ]; then
        if ! ${_IP6T} -t filter -S >/dev/null 2>&1 || ! ${_IP6T} -t nat -F >/dev/null 2>&1; then
            log "$SCRIPT_NAME" "IPv6 tables unavailable in current namespace"
            _IP6T=""
        fi
    fi
}

pick_ipv4_backend
pick_ipv6_backend
verify_ipv6_backend

# If we chose legacy for a family, clear any existing nft rules for that family to avoid mixed stacks
flush_nft_if_dirty_v4
flush_nft_if_dirty_v6

# Publish for other scripts
mkdir -p /run/xt
{
    printf 'IPT=%s\n' "$_IPT"
    printf 'IP6T=%s\n' "$_IP6T"
} > /run/xt/backend.env
chmod 0644 /run/xt/backend.env

. /run/xt/backend.env

# ---- secure defaults (v4 + v6 if available) --------------------------------

# Default DROP policies (set ASAP)
run4_critical -t filter -P OUTPUT DROP
run4_critical -t filter -P INPUT  DROP
run4_critical -t filter -P FORWARD DROP
run6_critical -t filter -P OUTPUT DROP
run6_critical -t filter -P INPUT  DROP
run6_critical -t filter -P FORWARD DROP

# Flush existing rules (filter + nat), best effort
run4_critical -t filter -F; run4_critical -t filter -X
run4_critical -t nat    -F; run4_critical -t nat    -X
run6_critical -t filter -F; run6_critical -t filter -X
run6_critical -t nat    -F; run6_critical -t nat    -X

# Allow loopback (critical for local apps)
run4 -A INPUT  -i lo -j ACCEPT
run4 -A OUTPUT -o lo -j ACCEPT

log "$SCRIPT_NAME" "Security rules applied - all traffic blocked by default"

exec /init "$@"
