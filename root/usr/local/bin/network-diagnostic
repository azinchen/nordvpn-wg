#!/bin/sh
# network-diagnostic: POSIX sh network diagnostics for a WireGuard-connected system (Docker-friendly)
# Usage: network-diagnostic [--basic|-b] | [--full|-f] | [--help|-h]
# Default mode is --full.

set -u  # be strict about undefined vars

MODE="full"

print_usage()
{
    cat <<'EOF'
Usage: network-diagnostic [options]
Usage: network-diagnostic [options]

Options:
    -b, --basic   Print only: "Public IP address X.X.X.X, location City CC"
    -f, --full    Full diagnostics (default)
    -h, --help    Show this help
EOF
}

# ---- Parse CLI --------------------------------------------------------------
while [ "$#" -gt 0 ]; do
    case "$1" in
        -b|--basic) MODE="basic" ;;
        -f|--full)  MODE="full"  ;;
        -h|--help)  print_usage; exit 0 ;;
        *) echo "Unknown option: $1" >&2; print_usage; exit 2 ;;
    esac
    shift
done

. /usr/local/bin/backend-functions

# ---- Tool discovery ---------------------------------------------------------
NFT_BIN="$(command -v nft 2>/dev/null || printf '')"
TR_BIN="$(command -v traceroute 2>/dev/null || printf '')"
[ -n "$TR_BIN" ] || TR_BIN="$(command -v tracepath 2>/dev/null || printf '')"
WG_BIN="$(command -v wg 2>/dev/null || printf '')"

# ---- Public IP helpers (prefer ipinfo.io) ----------------------------------
fetch_public_info()
{
    IP=""; CITY=""; CC=""
    RESP="$(curl -s --max-time 4 https://ipinfo.io/json 2>/dev/null || printf '')"
    if [ -n "$RESP" ]; then
        IP="$(printf "%s" "$RESP" | jq -r '.ip // empty' 2>/dev/null || printf '')"
        CITY="$(printf "%s" "$RESP" | jq -r '.city // empty' 2>/dev/null || printf '')"
        CC="$(printf "%s" "$RESP" | jq -r '.country // empty' 2>/dev/null || printf '')"
    fi
    if [ -z "$IP" ]; then
        IP="$(curl -s --max-time 4 https://ifconfig.co 2>/dev/null || printf '')"
        CITY="$(curl -s --max-time 4 https://ifconfig.co/city 2>/dev/null || printf '')"
        CC="$(curl -s --max-time 4 https://ifconfig.co/country-iso 2>/dev/null || printf '')"
    fi
}

print_basic()
{
    fetch_public_info
    if [ -n "$IP" ]; then
        echo "Public IP address $IP, location ${CITY:-Unknown} ${CC:-??}"
        exit 0
    else
        echo "Public IP address Unknown, location Unknown ??"
        exit 1
    fi
}

# If basic mode requested, do that and exit early.
if [ "$MODE" = "basic" ]; then
    print_basic
fi

# ---- Helpers: DNS nameserver geolocation & RTT ------------------------------
is_private_ip()
{
    case "$1" in
        10.*|192.168.*|172.1[6-9].*|172.2[0-9].*|172.3[0-1].*) return 0 ;;
        fd*|FD*|fc*|FC*|fe80*|FE80*) return 0 ;;
        *) return 1 ;;
    esac
}

# Query WireGuard interface for connection details
get_wireguard_status()
{
    if [ -z "$WG_BIN" ]; then
        return
    fi

    # Get endpoint from wg show
    ENDPOINT_RAW="$(wg show "$DEV_IF" endpoints 2>/dev/null | awk '{print $2}' | head -1 || printf '')"
    if [ -n "$ENDPOINT_RAW" ]; then
        TRUSTED_IP="$(printf "%s" "$ENDPOINT_RAW" | cut -d: -f1)"
        TRUSTED_PORT="$(printf "%s" "$ENDPOINT_RAW" | cut -d: -f2)"
    fi

    # Get public key of peer
    PEER_KEY="$(wg show "$DEV_IF" peers 2>/dev/null | head -1 || printf '')"

    # Get listening port
    LPORT="$(wg show "$DEV_IF" 2>/dev/null | awk '/listening port:/ {print $3}' || printf '?')"

    # Try to get server name from config file
    if [ -f "/etc/wireguard/$DEV_IF.conf" ]; then
        # Extract from # Server: comment
        COMMON_NAME="$(awk '/^# Server:/ {sub(/^# Server: /,""); print; exit}' "/etc/wireguard/$DEV_IF.conf" 2>/dev/null || printf '')"
        if [ -z "$COMMON_NAME" ]; then
            # Fallback to Endpoint
            COMMON_NAME="$(awk '/^[[:space:]]*Endpoint[[:space:]]*=[[:space:]]*/ {sub(/.*= /,""); print; exit}' "/etc/wireguard/$DEV_IF.conf" 2>/dev/null | cut -d: -f1 || printf '')"
        fi
    fi
    # Fallback: if IP, leave as is
}

# Get WireGuard interface details from system
get_interface_details()
{
    # Get local IP from interface
    IFCONF_LOCAL="$(ip addr show "$DEV_IF" 2>/dev/null | awk '/inet / {split($2,a,"/"); print a[1]; exit}' || printf '?')"

    # For WireGuard, remote IP is the peer endpoint
    IFCONF_REMOTE="$TRUSTED_IP"

    # Get VPN gateway from routes (usually the endpoint IP if routed)
    ROUTE_VPN_GW="$TRUSTED_IP"
}

ns_geo_line()
{
    IPQ="$1"
    if is_private_ip "$IPQ"; then
        echo "$IPQ : (private/local resolver)"
        return
    fi

    CITY=""; CC=""; ORG=""
    RESP="$(curl -s --max-time 4 "https://ipinfo.io/$IPQ/json" 2>/dev/null || printf '')"
    if [ -n "$RESP" ]; then
        CITY="$(printf "%s" "$RESP" | jq -r '.city // empty' 2>/dev/null || printf '')"
        CC="$(printf "%s" "$RESP" | jq -r '.country // empty' 2>/dev/null || printf '')"
        ORG="$(printf "%s" "$RESP" | jq -r '.org // empty' 2>/dev/null || printf '')"
    fi
    if [ -z "$CITY$CC$ORG" ]; then
        RESP="$(curl -s --max-time 4 "https://ipapi.co/$IPQ/json/" 2>/dev/null || printf '')"
        if [ -n "$RESP" ]; then
                CITY="$(printf "%s" "$RESP" | jq -r '.city // empty' 2>/dev/null || printf '')"
                CC="$(printf "%s" "$RESP" | jq -r '.country // empty' 2>/dev/null || printf '')"
                [ -n "$CC" ] || CC="$(printf "%s" "$RESP" | jq -r '.country_code // empty' 2>/dev/null || printf '')"
                ORG="$(printf "%s" "$RESP" | jq -r '.org // empty' 2>/dev/null || printf '')"
        fi
    fi
    [ -n "$CITY" ] || CITY="Unknown"
    [ -n "$CC" ] || CC="??"
    if [ -n "$ORG" ]; then
        echo "$IPQ : $CITY $CC â€” $ORG"
    else
        echo "$IPQ : $CITY $CC"
    fi
}

ns_rtt()
{
    NS="$1"
    POUT="$(ping -w 2 -c 2 "$NS" 2>/dev/null | awk -F'[/ ]' '/^rtt|^round-trip/{print $(NF-2)" ms"}')"
    [ -n "$POUT" ] && echo "  (avg RTT: $POUT)"
}

print_dns_geo()
{
    echo "### DNS servers geolocation"
    NS_LIST="$(awk '/^nameserver/ {print $2}' /etc/resolv.conf 2>/dev/null | sed 's/%.*//' | sort -u)"
    if [ -z "$NS_LIST" ]; then
        NS_LIST="$(resolvectl dns 2>/dev/null | tr ' ' '\n' | sed 's/%.*//' | \
            grep -E '^[0-9]+\.[0-9]+\.[0-9]+\.[0-9]+$|^[0-9a-fA-F:]+$' | sort -u)"
    fi
    if [ -z "$NS_LIST" ]; then
        echo "(no nameservers found)"
        echo
        return
    fi
    for NS in $NS_LIST; do
        ns_geo_line "$NS"
        ns_rtt "$NS"
    done
    echo
}

# ---- Full diagnostics (default) --------------------------------------------
PUBLIC_TEST_IPv4="1.1.1.1"
PUBLIC_TEST_IPv6="2606:4700:4700::1111"

# Initialize variables with defaults
COMMON_NAME=""
DEV_IF="wg0"
DEV_TYPE="wireguard"
IFCONF_LOCAL="?"
IFCONF_REMOTE="?"
ROUTE_VPN_GW="?"
TRUSTED_IP=""
TRUSTED_PORT=""
PROTO="wireguard"
LPORT="?"

# Try to get WireGuard status
get_wireguard_status

# Get interface details from system
get_interface_details

# Format trusted peer display
if [ -n "$TRUSTED_IP" ] && [ -n "$TRUSTED_PORT" ]; then
    TRUSTED_PEER="$TRUSTED_IP:$TRUSTED_PORT"
elif [ -n "$TRUSTED_IP" ]; then
    TRUSTED_PEER="$TRUSTED_IP:?"
else
    TRUSTED_PEER="?:?"
fi

echo "================================================================"
echo "WireGuard DIAG (full) : $(date -Is 2>/dev/null || date)"
if ip link show "$DEV_IF" >/dev/null 2>&1 && [ -n "$WG_BIN" ]; then
    VPN_STATUS="Connected"
else
    VPN_STATUS="Disconnected - No $DEV_IF interface or wg not available"
fi
echo "VPN Status            : $VPN_STATUS"
echo "Device                : $DEV_IF (type=$DEV_TYPE)"
echo "Common Name           : $COMMON_NAME"
echo "Ifconfig Local        : $IFCONF_LOCAL"
echo "Peer IP               : $IFCONF_REMOTE"
echo "Peer Endpoint         : $TRUSTED_PEER"
echo "Proto/Local Port      : $PROTO/$LPORT"
echo

echo "### ip addr show $DEV_IF"
ip addr show "$DEV_IF" 2>/dev/null || true
echo

echo "### wg show"
wg show 2>/dev/null || echo "[info] wg show failed or no wg interface"
echo

echo "### wg0.conf"
if [ -f /etc/wireguard/wg0.conf ]; then
    cat /etc/wireguard/wg0.conf | sed 's/PrivateKey = .*/PrivateKey = [REDACTED]/'
else
    echo "[info] wg0.conf not found"
fi
echo

echo "### ip link (up)"
ip -brief link show up 2>/dev/null || true
echo

echo "### ip route (main)"
ip route show 2>/dev/null || true
echo

echo "### ip rule"
ip rule show 2>/dev/null || true
echo

echo "### ip route table 51820"
ip route show table 51820 2>/dev/null || true
echo

# Default route / split-default detection
DEF_DEV="$(ip route show default 2>/dev/null | awk '/default/{for(i=1;i<=NF;i++) if($i=="dev"){print $(i+1); exit}}')"
DEV0="$(ip route show '0.0.0.0/1' 2>/dev/null | awk '{for(i=1;i<=NF;i++) if($i=="dev"){print $(i+1); exit}}')"
DEV128="$(ip route show '128.0.0.0/1' 2>/dev/null | awk '{for(i=1;i<=NF;i++) if($i=="dev"){print $(i+1); exit}}')"

if [ -n "$DEV0" ] && [ -n "$DEV128" ] && [ "$DEV0" = "$DEV_IF" ] && [ "$DEV128" = "$DEV_IF" ]; then
    echo "Default route dev     : (split default) $DEV_IF (0.0.0.0/1 + 128.0.0.0/1)"
    echo "[ok] Full-tunnel via split default detected"
else
    [ -n "${DEF_DEV:-}" ] || DEF_DEV="<none>"
    echo "Default route dev     : $DEF_DEV"
    if [ "$DEF_DEV" = "$DEV_IF" ]; then
        echo "[ok] Default route is via $DEV_IF"
    else
        # Check for policy routing to VPN table
        POLICY_VPN="$(ip rule show 2>/dev/null | grep -q "lookup 51820" && ip route show table 51820 2>/dev/null | grep -q "dev $DEV_IF" && echo "yes" || echo "no")"
        if [ "$POLICY_VPN" = "yes" ]; then
            echo "[info] Default route is via $DEF_DEV, but policy routing enforces VPN for internet traffic"
        else
            echo "[warn] Default route is NOT via $DEV_IF"
        fi
    fi
fi
echo

echo "### ip route get $PUBLIC_TEST_IPv4"
ip route get "$PUBLIC_TEST_IPv4" 2>/dev/null || true
echo

echo "### ip -6 route get $PUBLIC_TEST_IPv6"
ip -6 route get "$PUBLIC_TEST_IPv6" 2>/dev/null || echo "[info] no IPv6 route"
echo

# Netfilter snapshot
echo "### nftables / iptables rules"
if [ -n "$NFT_BIN" ]; then
    "$NFT_BIN" list ruleset 2>/dev/null || echo "[info] nft present, empty ruleset or no perms"
else
    echo "[info] nft not present"
fi

echo
echo "### iptables -S (filter)"
run4 -S 2>/dev/null || true

echo
echo "### iptables -t nat -S (IPv4 NAT)"
run4 -t nat -S 2>/dev/null || echo "(no IPv4 NAT rules or table unavailable)"

# Optional counters view (comment out if too verbose)
# echo
# echo "### iptables -t nat -L -n -v (counters)"
# "$IPT" -t nat -L -n -v 2>/dev/null || true

if [ -n "${IP6T}" ]; then
    echo
    echo "### ip6tables -S (filter)"
    run6 -S 2>/dev/null || true

    echo
    echo "### ip6tables -t nat -S (IPv6 NAT)"
    run6 -t nat -S 2>/dev/null || echo "(no IPv6 NAT rules or table unavailable)"
fi
echo

# Public IP & rough geo (JSON from same provider as summary)
echo "### Public IP / Geo (best-effort)"
RESP="$(curl -s --max-time 4 https://ipinfo.io/json 2>/dev/null || printf '')"
if [ -z "$RESP" ]; then
    RESP="$(curl -s --max-time 4 https://ifconfig.co/json 2>/dev/null || printf '')"
fi
if [ -n "$RESP" ]; then
    echo "$RESP" | jq . 2>/dev/null || echo "$RESP"
else
    echo "[warn] could not fetch public info"
fi
echo

# DNS configuration & identity probe
echo "### DNS configuration"
resolvectl status "$DEV_IF" 2>/dev/null || resolvectl status 2>/dev/null || true
echo

print_dns_geo

# Resolver identity (with fallbacks)
NS_ACTIVE="$(awk '/^nameserver/ {print $2; exit}' /etc/resolv.conf 2>/dev/null)"
if [ -n "$NS_ACTIVE" ]; then
    echo "### resolver identity via $NS_ACTIVE"
    OUT="$(dig +timeout=3 +short TXT whoami.cloudflare @"$NS_ACTIVE" 2>/dev/null | sed -n '1p')"
    if [ -z "$OUT" ]; then
        OUT="$(dig +timeout=3 +short CHAOS TXT id.server @"$NS_ACTIVE" 2>/dev/null | sed -n '1p')"
    fi
    if [ -z "$OUT" ]; then
        OUT="$(dig +timeout=3 +short CHAOS TXT hostname.bind @"$NS_ACTIVE" 2>/dev/null | sed -n '1p')"
    fi
    if [ -n "$OUT" ]; then
        echo "$OUT"
    else
        echo "(no identity TXT available from resolver)"
    fi
    echo
fi

# Connectivity probes
echo "### Ping checks"
ping -w 3 -c 3 "$PUBLIC_TEST_IPv4" 2>&1 || echo "[warn] ping to $PUBLIC_TEST_IPv4 failed"
ping6 -w 3 -c 3 "$PUBLIC_TEST_IPv6" 2>&1 || echo "[info] ping6 to $PUBLIC_TEST_IPv6 failed"
echo

if [ -n "$TR_BIN" ]; then
    echo "### Short trace to $PUBLIC_TEST_IPv4 (first hop should be VPN)"
    BN="$(basename "$TR_BIN" 2>/dev/null)"
    case "$BN" in
        tracepath) "$TR_BIN" -n -m 4 "$PUBLIC_TEST_IPv4" 2>&1 || true ;;
        *)         "$TR_BIN" -n -m 4 -w 2 "$PUBLIC_TEST_IPv4" 2>&1 || true ;;
    esac
    echo
fi

# Quick verdicts
echo "### Quick verdicts"
if [ "$VPN_STATUS" != "Connected" ]; then
    ROUTE_DEV="$(ip route get "$PUBLIC_TEST_IPv4" 2>/dev/null | awk '{for(i=1;i<=NF;i++) if($i=="dev"){print $(i+1); exit}}')"
    echo "[info] VPN disconnected - routes via local interface (${ROUTE_DEV:-<none>})"
else
    ROUTE_DEV="$(ip route get "$PUBLIC_TEST_IPv4" 2>/dev/null | awk '{for(i=1;i<=NF;i++) if($i=="dev"){print $(i+1); exit}}')"
    if [ -n "$ROUTE_DEV" ] && [ "$ROUTE_DEV" = "$DEV_IF" ]; then
        echo "[ok] Route to $PUBLIC_TEST_IPv4 goes via $DEV_IF"
    else
        echo "[warn] Route to $PUBLIC_TEST_IPv4 uses ${ROUTE_DEV:-<none>} (expected $DEV_IF)"
    fi
fi

fetch_public_info
if [ -n "${IP:-}" ]; then
    echo "Public IPv4 seen     : $IP"
    [ -n "$CITY" ] || CITY="Unknown"
    [ -n "$CC" ] || CC="??"
    echo "Location             : $CITY $CC"
fi

echo "Done."
echo "================================================================"
echo
exit 0
